散列表也叫哈希表或者hash表。

散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数据的一种扩展，由数组演化而来。

散列表用的就是数组支持按照下标随机访问的，时间复杂度是O（1）的特性。

散列函数设计的基本要求
1.散列函数计算得到的散列值是一个非负整数。因为数组下标是从0开始的，所以散列函数生成的散列值也要是非负整数。
2.如果key1==key2，那hash（key1）== hash(key2)
3.if key1 != key2, then hash(key1) != hash(key2)。

散列冲突
开放寻址法：如果出现了散列冲突，就是if key1 != key2, then hash(key1) != hash(key2)。那么就重新探测一个空闲位置，将其插入。


线性探测：
	当我们往散列表中插入数据的时候，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前的位置开始，依次往后查找，看是否有空闲位置，直到找打为止，如果找到后面都没有，就从头再找一次。删除了的元素，标记为deleted，线性检测到它的时候，继续往下探测。

二次探测：
	线性探测的步长是1，二次探测的步长变成了原来的二次方。

双重散列：
	不仅要使用一个散列函数，还要使用一组散列函数。如果用第一个散列函数被占用了，就用第二个散列函数。

用装载因子来表示空位的多少。
	散列表的装载因子 = 填入表的元素个数/散列表的长度。
	装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。

链表法
	在散列表中，每个桶或者槽会对应一条链表，所有散列值相同的元素，我们都放到相同槽位对应的链表中。


