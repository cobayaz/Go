散列表也叫哈希表或者hash表。

散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数据的一种扩展，由数组演化而来。

散列表用的就是数组支持按照下标随机访问的，时间复杂度是O（1）的特性。

散列函数设计的基本要求
1.散列函数计算得到的散列值是一个非负整数。因为数组下标是从0开始的，所以散列函数生成的散列值也要是非负整数。
2.如果key1==key2，那hash（key1）== hash(key2)
3.if key1 != key2, then hash(key1) != hash(key2)。

散列冲突
开放寻址法：如果出现了散列冲突，就是if key1 != key2, then hash(key1) != hash(key2)。那么就重新探测一个空闲位置，将其插入。


线性探测：
	当我们往散列表中插入数据的时候，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前的位置开始，依次往后查找，看是否有空闲位置，直到找打为止，如果找到后面都没有，就从头再找一次。删除了的元素，标记为deleted，线性检测到它的时候，继续往下探测。

二次探测：
	线性探测的步长是1，二次探测的步长变成了原来的二次方。

双重散列：
	不仅要使用一个散列函数，还要使用一组散列函数。如果用第一个散列函数被占用了，就用第二个散列函数。

用装载因子来表示空位的多少。
	散列表的装载因子 = 填入表的元素个数/散列表的长度。
	装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。

链表法
	在散列表中，每个桶或者槽会对应一条链表，所有散列值相同的元素，我们都放到相同槽位对应的链表中。

散列表碰撞攻击
	使用恶意的数据，使得所有的数据经过散列函数都散列到同一个槽里，这样再使用一个基于链表的冲突解决办法，散列表就会退化成链表。时间复杂度就会提高。

如何设计散列函数
	散列函数设计的好坏，决定了散列表冲突的概率大小，也直接决定了散列表的性能。
	散列表的设计不能太复杂，其次散列表生成的值要尽可能随机并且均匀分布、

装载因子过大怎么办？
	动态扩容。当装载因子大于一定值的时候，申请一个大小为两倍的链表，然后搬移数据，时间复杂度最低是O(1),最高是O(n)。
	装载因子的阈值的设计需要权衡时间、空间复杂度。如果内存空间不紧张，对执行效率要求很高，可以降低负债因子的阈值。

如何避免低效的扩容？
	把一次性的搬移，分解成为多次。

如何选择冲突解决办法？
	1.开放寻址法 当数据量比较小、装载因子小的时候，采用开放寻址法。
	2.链表法：对大装载因子的容忍度更高。适合大对象、大数据量的散列表。

LRU缓存淘汰算法
	在链表中，借助散列表，把LRU缓存淘汰算法的时间复杂度降低为O（1）。
	通过散列表去找到要操作数据的位置，然后用双向链表去实现添加数据还是删除数据等操作。涉及到添加，先去查询，如果有了就放到尾部，没有的话的还要查询是否已经满了。

Redis有序集合和java 的linkedhashmap都是用这种链表加散列表的方式实现的。

散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规则存储的。也就是无法支持按照某种顺序快速遍历数据。如果希望按照顺序遍历散列表中的数据，那么需要将散列表中的数据拷贝到数据组中，然后排序，遍历。

散列表是动态数据结构，不停的有数据的插入、删除，每当想按照顺序遍历散列表中的数据的时候，都需要先排序，那效率会很低。所以要将散列表和链表结合一起使用。

