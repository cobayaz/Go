没有父节点的节点叫做根节点、没有子节点的节点叫做叶子节点。

节点的高度：节点到叶子节点的最长路径（边数）
节点的深度：根节点到这个节点所经历的边的个数。
节点的层数：节点的深度加1.
树的高度：根节点的高度。

“高度”从下往上度量，从最底层开始计数。
“深度”从上往下度量。从根节点开始度量。
“层数”就是深度+1.

二叉树：每个节点最多只有两个叉。左子节点和右子节点。
	满二叉树：叶子结点全部在最底层，除了叶子节点，每个节点都有左右两个子节点。
	完全二叉树：叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其它层的节点个数都达到了最大。


如何表示（或存储）一颗二叉树？
	一种是基于指针或者引用的二叉链式存储法，一种是基于数组的顺序存储法。
	链式存储法：每个节点有三个字段：一个存储数据、另外两个指向左右子节点的指针。
	拎住根节点，就可以把整棵树都串起来。
	顺序存储法：根节点存储在下标i=1的位置，则左子节点存储在2*i的位置，右子节点存储在2*i+1的位置。这样只要知道根节点存储的位置（一般会存储在下标为i的位置），就可以通过下标计算，把整棵树都串起来了。如果是非完全二叉树会浪费比较多的数组存储空间。
	如果是完全二叉树，则用数组存储无疑是最节省内存的一种方式。因为数组存储方式不需要像链式存储法存储额外的左右子节点的指针。这也是完全二叉树的最后一层子节点都要靠左。
	堆就是一种完全二叉树，常用数组存储。

二叉树的遍历
	前序遍历、中序遍历、后序遍历。
	前序遍历：对于树中的任意节点来说，先打印这个节点，然后打印它的左子树，最后打印它的右子树。
	中序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。
	后序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。
	前序：自己->左->右
	中序：左->自己->右
	后序：左->右->自己
	二叉树遍历的时间复杂度是O（n）。

二叉查找树最大的特点就是：支持动态数据集合的快速插入、删除、查找操作。

二叉查找树
	也叫二叉搜索树。二叉查找树要求，在树中的任意一个节点，其左子树的每个节点的值都要小于这个节点的值，而右子树节点的值都大于这个节点的值。

二叉查找树的查找操作
	如果根节点等于要找的值就直接返回，要是小于就左子树递归遍历。大于就右子树递归遍历。

二叉树的插入操作
	从根节点依次比较要插入的数据和节点的大小关系。
	要插入的数据比节点的数据大，并且节点的右子树为空，就直接插入。
	如果不为空，就递归遍历右子树，查找插入位置。

二叉树的删除操作
	第一种情况：要删除的节点没有子节点，只需要直接将父节点中，指向要三处节点的指针置为null。
	第二种情况：如果要删除的节点只有一个子节点，只需要更新父节点中指向要删除的节点，让他指向要删除的节点的子节点。
	第三种情况：要删除的节点有两个子节点。需要找到这个节点的右子树的最小节点，把它替换到要删除的节点上，然后再删除掉这个最小节点。
	或者把它要删除的节点标记为“已删除”。只要的缺点会比较浪费内存空间。

二叉查找树的其他操作
	遇到相同的值，可以把它用链表都放在同一个位置，也可以放在右子树，但是遍历的时候要遍历下去直到找到叶子节点。

平衡二叉树的高度接近logn，所以时间复杂度也是O（logn）。

散列表和二叉查找树

- 散列表可以做到时间复杂度是O(1),而二叉查找树比较平衡的时候是O（logn）.
- 散列表的数据是无序的，要输出有序数据就需要先排序。对于二叉查找树，只需要中序遍- 历，就可以在时间复杂度是O（n）内，输出有序的数据序列。
- 散列表扩容耗时很多，而且遇到散列冲突的时候，性能不稳定。平衡二叉树的时间复杂度稳定在O（logn）。
- 因为哈希冲突的存在，散列表的效率不一定比平衡二叉树的效率高。
- 散列表的构造比较复杂，如散列函数的设计、冲突解决办法、扩容、缩容等。




