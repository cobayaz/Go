- 冒泡排序
- 插入排序
- 选择排序
- 快速排序
- 归并排序
- 计算排序
- 基数排序
- 桶排序


按照复杂度归类
	- 冒泡排序、插入排序、选择排序  O(n^2)
	- 
	- 快速排序、归并排序O(nlogn)
	- 
	- 计算排序、基数排序、桶排序 O(n)

冒泡排序
	冒泡排序指挥操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求，如果不满足就让他们两个互换。

	冒泡排序是稳定的排序算法。（稳定性概念：待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。）

	冒泡排序是原地排序算法。（空间复杂度是O（1）的排序算法。）

	时间复杂度：
	最好情况（满有序度）：O(n)。

	最坏情况（满逆序度）：O(n^2)。

	平均情况：

	“有序度”和“逆序度”：对于一个不完全有序的数组，如4，5，6，3，2，1，有序元素对为3个（4，5），（4，6），（5，6），有序度为3，逆序度为12；对于一个完全有序的数组，如1，2，3，4，5，6，有序度就是n*(n-1)/2，也就是15，称作满有序度；逆序度=满有序度-有序度；冒泡排序、插入排序交换（或移动）次数=逆序度。

插入排序
	插入排序将数组数据分成已排序区间和未排序区间。初始已排序区间只有一个元素，即数组第一个元素。在未排序区间取出一个元素插入到已排序区间的合适位置，直到未排序区间为空。

	空间复杂度：插入排序是原地排序算法。

选择排序
	选择排序将数组分成已排序区间和未排序区间。初始已排序区间为空。每次从未排序区间中选出最小的元素插入已排序区间的末尾，直到未排序区间为空。

	空间复杂度：选择排序是原地排序算法。

	时间复杂度：（都是O(n^2)）


归并排序
	归并排序，使用的是分治的思想，把一个大问题分解成小的子问题来解决，小问题解决完了，大问题也迎刃而解了。
	分治算法一般都是用递归实现的，分治是一种解决问题的处理思想，递归是一种编程技巧。
	归并排序是申请一个临时数组，大小和要比较的数组相同，然后用两个游标分别指向要比较的数组如大小为10的（a[0]和a[5]），然后两两比较，如果a[0]<a[5]，就把a[0]放进去那个临时数组，然后再指向a[1],若a[1]>a[5]，就把a[5]放进去数组，以此类推，直到其中一个子数组全部放进去临时数组，再把另一个数组的数据按顺序放入，最后临时数组就是一个排序好的了，再把临时数组拷贝进去。

	归并排序是一个稳定的排序算法。
	归并排序的时间复杂度是O(nlogn)，空间复杂度是O(n)
	归并排序不是原地排序算法。

快速排序
	快排就是利用分治的思想，选择数组的首尾中的一个数据作为分界点，然后遍历数组里面的数据，比分界点小的放在左边，比分界点大的 放在右边。遍历完了就会发现数据变成一个有序的数组了。

归并排序和快速排序
	归并排序的处理过程是由下到上的，先处理子问题，然后合并。
	快速排序相反，先分好两个区，然后再处理子问题。
	归并是非原地排序算法，是因为合并函数不能在原地执行，快速排序通过设计巧妙的原地风趣，可以实现原地排序。
	快速排序是一种原地、不稳定的排序算法。
	
