- 冒泡排序
- 插入排序
- 选择排序
- 快速排序
- 归并排序
- 计算排序
- 基数排序
- 桶排序


按照复杂度归类
	- 冒泡排序、插入排序、选择排序  O(n^2)
	- 
	- 快速排序、归并排序O(nlogn)
	- 
	- 计算排序、基数排序、桶排序 O(n)

冒泡排序
	冒泡排序指挥操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求，如果不满足就让他们两个互换。

	冒泡排序是稳定的排序算法。（稳定性概念：待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。）

	冒泡排序是原地排序算法。（空间复杂度是O（1）的排序算法。）

	时间复杂度：
	最好情况（满有序度）：O(n)。

	最坏情况（满逆序度）：O(n^2)。

	平均情况：

	“有序度”和“逆序度”：对于一个不完全有序的数组，如4，5，6，3，2，1，有序元素对为3个（4，5），（4，6），（5，6），有序度为3，逆序度为12；对于一个完全有序的数组，如1，2，3，4，5，6，有序度就是n*(n-1)/2，也就是15，称作满有序度；逆序度=满有序度-有序度；冒泡排序、插入排序交换（或移动）次数=逆序度。

插入排序
	插入排序将数组数据分成已排序区间和未排序区间。初始已排序区间只有一个元素，即数组第一个元素。在未排序区间取出一个元素插入到已排序区间的合适位置，直到未排序区间为空。

	空间复杂度：插入排序是原地排序算法。

选择排序
	选择排序将数组分成已排序区间和未排序区间。初始已排序区间为空。每次从未排序区间中选出最小的元素插入已排序区间的末尾，直到未排序区间为空。

	空间复杂度：选择排序是原地排序算法。

	时间复杂度：（都是O(n^2)）


归并排序
	归并排序，使用的是分治的思想，把一个大问题分解成小的子问题来解决，小问题解决完了，大问题也迎刃而解了。
	分治算法一般都是用递归实现的，分治是一种解决问题的处理思想，递归是一种编程技巧。
	归并排序是申请一个临时数组，大小和要比较的数组相同，然后用两个游标分别指向要比较的数组如大小为10的（a[0]和a[5]），然后两两比较，如果a[0]<a[5]，就把a[0]放进去那个临时数组，然后再指向a[1],若a[1]>a[5]，就把a[5]放进去数组，以此类推，直到其中一个子数组全部放进去临时数组，再把另一个数组的数据按顺序放入，最后临时数组就是一个排序好的了，再把临时数组拷贝进去。

	归并排序是一个稳定的排序算法。
	归并排序的时间复杂度是O(nlogn)，空间复杂度是O(n)
	归并排序不是原地排序算法。

快速排序
	快排就是利用分治的思想，选择数组的首尾中的一个数据作为分界点，然后遍历数组里面的数据，比分界点小的放在左边，比分界点大的 放在右边。遍历完了就会发现数据变成一个有序的数组了。

归并排序和快速排序
	归并排序的处理过程是由下到上的，先处理子问题，然后合并。
	快速排序相反，先分好两个区，然后再处理子问题。
	归并是非原地排序算法，是因为合并函数不能在原地执行，快速排序通过设计巧妙的原地风趣，可以实现原地排序。
	快速排序是一种原地、不稳定的排序算法。
	
桶排序、计数排序、基数排序都是线性排序，是因为这三个算法都是非基于比较的排序算法，都不涉及元素之间的比较操作。<br>这三种排序算法对排序的数据要求很苛刻。


桶排序
	核心思想是将要排序的数据分到几个有序的桶里，每个桶的数据再单独进行排序。桶里的排完序之后，再把每个桶里的数据依照顺序依次取出，组成的数据就是有序的了。
	如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶,，每个桶里就有 k=n/m 个元素。每个桶内部使用快速排序,时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(n*log(n/m))。当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。
	桶排序比较适合用在外部排序中，就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。
	核心就是：把大量的数据，均分进多个桶里面，然后在里面进行排序，排序好再依次拿出。


计算排序
	计数排序是桶排序的一种特殊情况，要排序的n个数据，所处的范围并不大的时候，如最大值是0-k（int），就可以分为k个桶。
	技术排序只能用在数据范围不大的场景中，如果数据范围K要比排序的数据n大很多，就不适合用计数排序了。而且计数排序只能给非负整数排序，如果要排序的数据是其它类型的，要将其在不改变相对大小的情况下，转化为非负整数。

基数排序
	基数排序是对排序的数据有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果a数据的高位比b数据打，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则基数排序的时间复杂度就没法做到O（n）了、



| 排序  | 时间复杂度 | 是否稳定排序(Y/N) | 是否原地排序(Y/N) | 
---|:---:|:---:|:---:|---
冒泡排序 | O(n^2) | Y | Y | 
插入排序 | O(n^2) | Y | Y | 
选择排序 | O(n^2) | N | Y |
快速排序 | O(nlogn) | N | Y | 
归并排序 | O(nlogn) | Y | N | 
计数排序 | O(n+k)k是数据范围 | Y | N | 
桶排序 | O(n) | Y | N | 
基数排序 | O(dn)d是维度 | Y | N | 


