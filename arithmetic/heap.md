堆排序是一种原地的、时间复杂度为O(nlogn)的排序算法。

快速排序的时间复杂度也是O(nlogn)。

堆是一种特殊的树。
	堆是一个完全二叉树、
	堆中每一个节点的值都必须大于等于（或者小于等于）其子树中每个节点的值。
	每个节点的值都大于等于子树中每个节点值的堆，叫做“大顶堆”。
	对于每个节点的值都小于等于子树中每个节点值的堆，叫做小顶堆。

如何实现一个堆
	完全二叉树比较适合用数组来存储。
	往堆中插入一个元素。有时候需要进行调整，让其重新满足堆的特性，叫做堆化。就是拿它和父节点来比较，假如比父节点大就交换位置，一直到符合条件为止。
	删除堆顶元素。假设是大顶堆，删除了堆顶元素之后，就要把第二大的元素放到堆顶，不断地迭代删除子节点，直到子节点被删除。
	往堆中插入一个元素和删除堆顶元素的时间复杂度都是O（logn）。

如何基于堆实现排序？
	时间复杂度相当稳定O(nlogn),而且还是原地排序算法。
	建立堆：
		时间复杂度是O（n）.排序过程的时间复杂度是O(nlogn)。
		堆排序不是稳定的排序算法。存在将堆的最后一个节点跟堆顶节点互换的操作，就有可能改变值相同数据的原始相对顺序。

堆排序数据访问的方式没有快速排序友好。
	对于快速排序来说，数据是顺序访问的。对于堆排序来说，数据是跳着访问的。

对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。

堆排序包含两个过程：建堆和排序。
	建堆：下标从n/2到1的节点，一次进行冲上到下堆化操作，然后将数组中的数据组织成堆这种数据结构。
	接下来迭代地将堆顶的元素放到堆的末尾，并将堆的大小减1，然后再堆化，重复这个过程，直到堆中只剩下一个元素，整个数组中的数据就有序排列了。