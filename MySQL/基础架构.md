看一个事儿千万不要直接陷入细节里，应该先鸟瞰其全貌，从高纬度理解问题。

MySQL可以分为server层和存储引擎层。

server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖了MYSQL的大多数核心服务功能。

存储引擎层负责数据的存储和提取。默认使用引擎是innoDB。

MYSQL执行步骤：
- 连接器：连接器负责跟客户端建立连接、获取权限、维持和管理连接。
- 查询缓存：mysql拿到查询请求，先到一个缓存里面看看是否存在，如果存在就会直接返回，不执行后面的复杂操作，以一个key：value的形式存在。
	可是查询缓存的失效很频繁，对一个表的更新，这个表上所有的查询缓存都会被清空。对于更新压力大的数据库，查询缓存的命中率非常低。mysql8.0之后版本没有了缓存的功能
- 分析器：对SQL语句做解析。
	1）mysql会先做“词法解析”，识别出字符串里面的关键字，知道他们是什么，要怎么用。
	2）做完识别会做“语法分析”，根据语法规则，判断sql语句是否满足mysql语法。若语法不对，会提示出现在“use  near”后面的内容。
- 优化器：优化器是在有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。选择最优的执行方案，提高效率。
- 执行器：分析器知道你要做什么，优化器知道你应该怎么做。执行器执行语句。执行前，先判断你有没有权限。有权限就会打开表继续执行，打开表会根据表的引擎定义，使用这个引擎提供的接口。就是每一行调用引擎提供的接口去查询，又说要的也差不多。rows_examined引擎扫描行数，看看它扫描了多少行。
  
如果字段不存在会报错，unknown column 'k' in .... 是在分析器阶段报错的。

一条查询语句的执行过程一般是，经过连接器、分析器、优化器、执行器等功能模块，最后到达存储引擎。

##一条更新语句的执行步骤

	更新流程涉及到两个重要的日志模块：redo log(重做日志)和binlog(归档日志)。

###重要的日志模块：redo log

	MySQL的WAL技术：Write-Ahead Logging,关键点是先写日志，再写磁盘。先在小粉板上记录，不忙的时候再把大账本出来对照。
	所以当一条记录需要更新的时候，InnoDB引擎会将记录写到redo log（小黑板）上，并且更新内存，这时候就算更新完成了。同时InnoDB会在系统空闲的时候，把这个更新记录到磁盘里。
	redo log是固定大小的，假如不够写了，要先擦除部分记录，先存进磁盘。
	有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力叫做crash-safe。

###重要的日志模块：binlog

	redo log是InnoDB引擎特有的日志，sever特有的日志称为binlog，所有引擎都可以使用。
	redo是物理日志，binlog是逻辑日志，记录的是这个语句的原始逻辑。
	redo log是循环写的，空间固定会用完；binlog是可以追加写入的，binlog文件到达一定大小之后，会切换到下一个，不会覆盖以前的日志。


redo log和binlog都可以用于表示事务的提交状态，而两阶段的提交就是让这两个状态保持逻辑上的一致。
redo log用于保证crash-safe能力。innodb_flush_log_at_trx_commit参数设置为1的时候，表示事务的redo log都直接持久化到磁盘。
sync_binlog参数设置为1的时候，表示每次事务的binlog都持久化到磁盘，可以保证mysql异常重启之后binlog不丢失。



##事务系统

	事务就是要保证一组数据操作，要么全部成功，要么全部失败。MYSQL中，事务支持实在引擎层实现的。MySQL原生的MyISAM引擎就不支持事务，这也是MyISAM被InnoDB取代的重要原因之一。
	多事务同时执行的时候，可能会出现的问题：脏读、不可重复读、幻读。

事务有4大特性:ACID。
	Atomicity:原子性。 Consistency：一致性。 Isolation:隔离性。 Durability：持久性。

Isolation:隔离性。
	隔离的越严实，效率就会越低。所以要取一个平衡。
	SQL标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repatable read）、串行化（serializable）。
	读未提交：一个事务还没提交的时候，它做的变更就能被其它事务看到。
	读提交：一个事务提交之后，它做的变更才会被其它事务看到。
	可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
	串行化，就是对于同一行记录，“写”会加“写锁”，读会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才可继续执行。
	oracle数据库的默认隔离级别就是“读提交”。

事务隔离的实现：每条记录在更新的时候都会同时记录一条回滚操作。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）