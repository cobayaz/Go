数据库锁设计的初衷是处理并发问题。

MySQL的锁大致分为全局锁、表级锁和行锁。

全局锁
	全局锁的典型使用场景是：做全库逻辑备份。把整个库每个表都select出来存成文本。
	一个库被全局锁上以后，你要对里面任何一个表做加字段操作，都会被锁住的。
	对于全部是InnoDB引擎的库，建议选择使用-single-transaction参数。

表级锁
	MySQL的表级别锁有两种，一种是表锁，一种是元数据锁（meta data lock,MDL）。
	MDL会直到事务提交之后才释放，在做表结构更改的时候，一定要小心。不要导致锁住线上查询和更新。

行锁
	行锁是在引擎层由各个引擎自己实现，但是myisam不支持行锁，所并发控制只能使用表锁，同一张表上任何时刻只能有一个更新在执行。InnoDB支持行锁。

	行锁就是针对数据表中行记录的锁。

两阶段锁
	在InnoDB事务中，行锁是在需要的时候才加上去的，但并不是不需要了就立刻释放，而是要等到事务结束的时候才释放。这就是两阶段锁协议。
	所以，如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。

死锁和死锁检测
	当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无线等待的状态，称为死锁。
	出现死锁后的策略：
	1.直接进入等待，直到超时。通过innodb_lock_wait_timeout设置。（默认是50s，一个被锁住的线程过50s才会退去，然后其他继续执行。）
	2.发起死锁检测，发现死锁之后，回滚死锁链条中的某一个事务，让其他事务得以继续执行。设置innodb_deadlock_detect为on开启逻辑。主动死锁在发生死锁的时候，能够快速发现并且进行处理。但是存在额外负担：每一个事务被锁的时候，都要看它所依赖的线程有没有被别人锁住，如此循环，最后进行判断。时间复杂度是O(n),1000个并发线程要更新同一行，死锁检测操作就是100万量级。

解决死锁检测耗费大量资源问题
	1.确保不会出现死锁的情况下，把死锁检测关掉。
	2.控制并发度。在数据库服务度，在中间件实现。或者修改mysql源码，在对于相同行的更新，在进入引擎之前排队。
	3.将一行改成逻辑上的多行来减少锁冲突。

如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁的申请时间尽量往后放。
