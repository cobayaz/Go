索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。

提高读写效率的数据结构有很多，如哈希表、有序数组、搜索树。

哈希表是一个key-value存储数据的结构，输入key找到value。把值放在数组里，用一个哈希函数，把key换算成一个确定的位置，然后把value放在数组的这个位置。

多个key出现同一个值的情况下，会拉出一个链表。

因为哈希表的key不是顺序递增的，好处就是新增的时候，直接尾部添加。坏处就是查询的时候很慢。所以哈希表的这个结构适用于只有等值查询的场景。

有序数组在等值查询和范围你查询场景中的性能都非常优秀。
有序数组查询效率极高，底层是数组结构，有序，但是缺点是新增记录的时候要挪动大数据。所以有序数组只适用于静态存储引擎。就不会被修改的数据。

二叉搜索树。每个节点的左儿子小于父节点，父节点又小于右儿子。时间复杂度是O(logn)。
二叉树是搜索效率最高的，但是实际上大多数的数据库存储并不使用二叉树，因为索引不止存在内存中，还要写到磁盘上。所以要采用N叉树存储。


数据库底层存储的核心就是基于这些数据模型的。每碰到一个新数据库，要去先关注它的数据模型，这样才能理论上分析出这个数据库的使用场景。

在MySQL中，索引实在存储引擎层实现的，所以没有统一的索引标准。

InnoDB的索引模型
	在InnoDB中，表都是根据主键顺序以索引的形式存放的，这存储方式又称为索引组织表。数据存储在B+树种，InnoDB使用B+树索引模型。
	每一个索引在innodb中对应一颗B+树。
	索引类型分为主键索引（聚簇索引）和非主键索引（二级索引）。
	基于非主键索引的查询要多扫描一棵索引树。
	主键索引的叶子节点存的是整行的数据，非主键索引的叶子节点内容是主键的值。所以要多扫描一次主键树。扫描主键索引直接就可以拿到数据。

索引维护
	B+树为了维护索引有序性，在插入新值的时候需要做必要的维护。
	页分裂：原有的树已经满了，要申请一个新的数据页。
	对应有页合并。
	自增主键不涉及数据搬移，所以性能较好，而且占用空间较小。
	主键长度越小，普通索引的叶子结点就越小，普通索引占用的空间也就越小。
	所以从性能和存储空间方面考量，自增主键会是优先选择。
	适合用业务制度按做主键的：
		1。只有一个索引。
		2.该索引必须是唯一索引。即是KV场景。
		由于没有其他索引，所以不需要考虑其他索引的叶子节点大小的问题。直接将这个索引设置为主键，就可以避免每次查询都要搜索两棵树。

B+树可以很好的配合磁盘的读写特性，减少单次查询的磁盘访问次数。
innodb是索引组织表，创建自增主键，这样非主键索引占用的空间最小。

回到主键索引树搜索的过程，我们称为回表。

覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。

索引字段的维护总是有代价的。因此在建立冗余索引来支持覆盖索引的时候就需要权衡考虑。这就是业务DBA的工作。

最左前缀原则
	B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。
	第一原则：如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。
	其次是空间原则，用比较大的字段去建联合索引，另一个小的做单字段索引。

索引下推
	在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

在满足语句需求的情况下，尽量少地访问资源是数据库设计的重要原则之一。

我们在使用数据库的时候，尤其是在设计表结构的时候，也要以减少资源消耗作为目标。