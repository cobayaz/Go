索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。

提高读写效率的数据结构有很多，如哈希表、有序数组、搜索树。

哈希表是一个key-value存储数据的结构，输入key找到value。把值放在数组里，用一个哈希函数，把key换算成一个确定的位置，然后把value放在数组的这个位置。

多个key出现同一个值的情况下，会拉出一个链表。

因为哈希表的key不是顺序递增的，好处就是新增的时候，直接尾部添加。坏处就是查询的时候很慢。所以哈希表的这个结构适用于只有等值查询的场景。

有序数组在等值查询和范围你查询场景中的性能都非常优秀。
有序数组查询效率极高，底层是数组结构，有序，但是缺点是新增记录的时候要挪动大数据。所以有序数组只适用于静态存储引擎。就不会被修改的数据。

二叉搜索树。每个节点的左儿子小于父节点，父节点又小于右儿子。时间复杂度是O(logn)。
二叉树是搜索效率最高的，但是实际上大多数的数据库存储并不使用二叉树，因为索引不止存在内存中，还要写到磁盘上。所以要采用N叉树存储。


数据库底层存储的核心就是基于这些数据模型的。每碰到一个新数据库，要去先关注它的数据模型，这样才能理论上分析出这个数据库的使用场景。

在MySQL中，索引实在存储引擎层实现的，所以没有统一的索引标准。

InnoDB的索引模型
	在InnoDB中，表都是根据主键顺序以索引的形式存放的，这存储方式又称为索引组织表。数据存储在B+树种，InnoDB使用B+树索引模型。
	每一个索引在innodb中对应一颗B+树。
	索引类型分为主键索引（聚簇索引）和非主键索引（二级索引）。
	基于非主键索引的查询要多扫描一棵索引树。
	主键索引的叶子节点存的是整行的数据，非主键索引的叶子节点内容是主键的值。所以要多扫描一次主键树。扫描主键索引直接就可以拿到数据。

索引维护
	B+树为了维护索引有序性，在插入新值的时候需要做必要的维护。
	页分裂：原有的树已经满了，要申请一个新的数据页。
	对应有页合并。
	自增主键不涉及数据搬移，所以性能较好，而且占用空间较小。
	主键长度越小，普通索引的叶子结点就越小，普通索引占用的空间也就越小。
	所以从性能和存储空间方面考量，自增主键会是优先选择。
	适合用业务制度按做主键的：
		1。只有一个索引。
		2.该索引必须是唯一索引。即是KV场景。
		由于没有其他索引，所以不需要考虑其他索引的叶子节点大小的问题。直接将这个索引设置为主键，就可以避免每次查询都要搜索两棵树。

B+树可以很好的配合磁盘的读写特性，减少单次查询的磁盘访问次数。
innodb是索引组织表，创建自增主键，这样非主键索引占用的空间最小。