1.数据库更新操作的时候有时候会抖动一下？

	WAL技术，数据库将随机写转换成为顺序写，大大提升了数据库的性能。
	但是因此带来的内存脏页问题，脏页会被后台线程自动flush，也会由于数据页淘汰而触发flush，而刷脏页过程由于会占用资源，导致更新和查阅语句会长一些。

2.为什么表数据删除了一半，表文件大小却不变？

	如果要收缩一个表，只是delete掉表中不用的数据的话，表文件的大小是不会变的，因为它只是把那个位置标识为可复用。还要通过alter table命令去重建表，才能达到表文件变小的目的。
	重建表有OnlineDDL和inreplace，inreplace会占用存储空间。OnlineDDL是在业务低峰期使用，在mysql5.5之前还会阻塞DML


3.count(*)这么慢，我改怎么办？

	- InnoDB是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。
	- 在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。
	- MyISAM表虽然count(*)快，但是不支持事务，它是直接存一个总数，到时候直接读。
	- show table status会显示这个表当前有多少行，但是它是根据索引统计的值采样估算的 ，很不准。
	- InnoDB表会count(*)会遍历全表，结果准确，但是会导致性能问题。
	- 按照效率，count(字段)<count(主键id)<count(1)约等count(*)。尽量使用count(*)。
	- 解决办法：用一个mysql的表存储count的数量，存储这个表的时候利用好事务的原子性和隔离性，简化在业务开发的逻辑。
	- 从考虑并发系统性能的角度，在用事务确保计数正确，但是事务保证中间结果不被别的事务读取，所以修改计数值和插入记录的顺序不会影响逻辑结果。那应该以一个什么样的顺序呢？
	- 答案是：先插入操作记录，再更新计数表。因为更新计数表设计到行锁竞争，先插入再更新能最大程度减少了事务之间的锁等待，提升并发度。

4."oredr by"是怎么工作的？

	- Mysql会给每个线程分配一块内存用于排序，称为sort_buffer。
	- select city,name,age from t where city='杭州' order by name limit 1000  ;
	- 执行顺序：
	- 1.先初始化sort_buffer,然后放入要查找的name,age city上个字段。
	- 2.从索引city（在where用到的 字段加索引，提高效率）找到第一个满足city=“杭州”条件的主键id。
	- 3.到主键id索引取出整行，取name, city, age三个字段的值，存进sort_buffer。
	- 4.从索引city取下一个记录的主键id
	- 5.重复3.4知道city的值不满足查询条件为止。
	- 6.对sort_buffer中的数据按照字段name做快速排序。
	- 7.按照排序结果取出前1000行返回给客户端。
	- MySQL认为排序的单行长度太大的时候会采用rowid排序。
	- 如果MySQL担心排序内存太小，会影响排序效率，才会采用rowid排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。
	- 如果MySQL认为内存足够大，会优先选择全字段排序，把需要的字段都放到sort_buffer中，这样排序后就会直接从内存中返回查询结果了，不用再回到原表取数据。
	- M有SQL的一个设计思想，如果内存够，就要多利用内存，尽量减少磁盘访问。
	- 采用覆盖索引（索引上的信息足够满足查询请求，不需要再回到主键索引上去取数据。），把用到的name和city联合起来做索引，这样取出的时候就有顺序了，性能会变快。

5.如何正确的显示随机消息？

	尽量将业务逻辑写在业务代码中，让数据库只做“读写数据”的事情。
	mysql> select word from words order by rand() limit 3;
	也可以用rand()*(max-min)