1.数据库更新操作的时候有时候会抖动一下？

	WAL技术，数据库将随机写转换成为顺序写，大大提升了数据库的性能。
	但是因此带来的内存脏页问题，脏页会被后台线程自动flush，也会由于数据页淘汰而触发flush，而刷脏页过程由于会占用资源，导致更新和查阅语句会长一些。

2.为什么表数据删除了一半，表文件大小却不变？

	如果要收缩一个表，只是delete掉表中不用的数据的话，表文件的大小是不会变的，因为它只是把那个位置标识为可复用。还要通过alter table命令去重建表，才能达到表文件变小的目的。
	重建表有OnlineDDL和inreplace，inreplace会占用存储空间。OnlineDDL是在业务低峰期使用，在mysql5.5之前还会阻塞DML


3.count(*)这么慢，我改怎么办？

	- InnoDB是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。
	- 在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。
	- MyISAM表虽然count(*)快，但是不支持事务，它是直接存一个总数，到时候直接读。
	- show table status会显示这个表当前有多少行，但是它是根据索引统计的值采样估算的 ，很不准。
	- InnoDB表会count(*)会遍历全表，结果准确，但是会导致性能问题。
	- 按照效率，count(字段)<count(主键id)<count(1)约等count(*)。尽量使用count(*)。
	- 解决办法：用一个mysql的表存储count的数量，存储这个表的时候利用好事务的原子性和隔离性，简化在业务开发的逻辑。
	- 从考虑并发系统性能的角度，在用事务确保计数正确，但是事务保证中间结果不被别的事务读取，所以修改计数值和插入记录的顺序不会影响逻辑结果。那应该以一个什么样的顺序呢？
	- 答案是：先插入操作记录，再更新计数表。因为更新计数表设计到行锁竞争，先插入再更新能最大程度减少了事务之间的锁等待，提升并发度。

4."oredr by"是怎么工作的？

	- Mysql会给每个线程分配一块内存用于排序，称为sort_buffer。
	- select city,name,age from t where city='杭州' order by name limit 1000  ;
	- 执行顺序：
	- 1.先初始化sort_buffer,然后放入要查找的name,age city上个字段。
	- 2.从索引city（在where用到的 字段加索引，提高效率）找到第一个满足city=“杭州”条件的主键id。
	- 3.到主键id索引取出整行，取name, city, age三个字段的值，存进sort_buffer。
	- 4.从索引city取下一个记录的主键id
	- 5.重复3.4知道city的值不满足查询条件为止。
	- 6.对sort_buffer中的数据按照字段name做快速排序。
	- 7.按照排序结果取出前1000行返回给客户端。
	- MySQL认为排序的单行长度太大的时候会采用rowid排序。
	- 如果MySQL担心排序内存太小，会影响排序效率，才会采用rowid排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。
	- 如果MySQL认为内存足够大，会优先选择全字段排序，把需要的字段都放到sort_buffer中，这样排序后就会直接从内存中返回查询结果了，不用再回到原表取数据。
	- M有SQL的一个设计思想，如果内存够，就要多利用内存，尽量减少磁盘访问。
	- 采用覆盖索引（索引上的信息足够满足查询请求，不需要再回到主键索引上去取数据。），把用到的name和city联合起来做索引，这样取出的时候就有顺序了，性能会变快。

5.如何正确的显示随机消息？

	尽量将业务逻辑写在业务代码中，让数据库只做“读写数据”的事情。
	mysql> select word from words order by rand() limit 3;
	也可以用rand()*(max-min)
	考虑到随机的结果的概率是否均等，以及执行起来的效率。

6.为什么这些SQL语句逻辑相同，性能差异却巨大？

	- 如果对字段做了函数计算，就用不上索引了，这是MySQL的规定。
	- 对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。但并不是要放弃这个索引。
	- 由于使用了函数操作，MySQL无法再使用索引快速定位功能，而只能使用全表扫描。
	- select * from table where id + 1 = 10000,这条语句，MySQL不能用id索引快速定位到9999这一行，所以要手动改成where id = 10000 - 1.所以MySQL用到函数的时候不会用到索引。
	- MySQL中，字符串和数字做比较的话，是将字符串转换成数字。
	- 所以字符串是string类型的，你输入一个int类型，会涉及类型转换，就不走索引，从而变成全局扫描。

7.为什么我只查一行的数据，也执行这么慢？

	查询长时间不返回的
	- 大概率是表被锁住了（show processlist查看当前语句处于什么状态）
	- 等MDL锁，waitiing for table metadata lock，有一个线程正在表t上请求或者持有MDL锁，把select语句堵住了。解决方案：找到谁持有MDL写锁，kill掉 select blocking_pid from sys.schema_table_lock_waits.
	- 等flush，select语句被flush命令堵住了。
	- 等行锁。读写，被事务中的写锁锁住，且写锁没有commit，读锁会堵塞，解决方案，kill掉写锁。
	- 查询慢。没有索引，导致扫描行数多，所以执行起来慢。
	- 开启事务，之后才执行update语句，会执行很多次，生成很多undo log，导致执行起来慢。

8.幻读是什么，幻读有什么问题？

	- 在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。所以幻读只会在「当前读」下才会出现。
	- 幻读专指“新插入的行”。
	- 间隙锁和行锁合称next-key lock，每个next-key lock都是前开后闭区间。


9.MySQL有哪些饮鸩止渴提高性能的方法？

	- 短连接风暴。
	- MySQL的max_connections，控制一个MySQL实例同时存在的连接数的上限。超过这个上限，就会报错提示“too many connection”。不能盲目调高这个最大连接数，因为调大了，虽然你连接的数量提升了，但是那样进一步加大了系统的负载，大量资源耗费在权限验证上，结果那些连接的线程反而拿不到CPU资源去执行SQL操作，性能更低了。
	- 解决方案：先处理掉那些占着连接但是不工作的线程。通过命令查看它是否在运行。
	- 减少连接过程的消耗。使用-skip-grant-tables参数启动。但是这个会巨危险。别人会入侵，你会很麻烦。
	- 慢查询性能问题：
	- 1.索引没有设计好，通过紧急设计索引来解决。主备库切换，先在备库设置好，然后把备库和主库切换，再设置主库，设置完毕再切换回去。
	- 2.SQL语句没有写好，语句写成了如：select * from t where id +1 = 10000,应该改成select * from t where id  = 10000 - 1，
	- 3.MySQL选错了索引，选错索引可以使用force index，强制使用索引。
	- 更多时候应该在上线前就做好压力测试，减少发生故障的伤害。
	- QPS突增问题，要么把它从白名单移除，或者断开用户连接